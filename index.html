<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <!-- Informaﾃｧﾃｵes bﾃ｡sicas da pﾃ｡gina -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Uma das melhores alternativas caso o site da Doritos caia ou fique offline!" />
    <meta name="keywords"
        content="TarefaSP hacks, TarefaSP scripts, Sala do Futuro hacks, Sala do Futuro scripts, Sala Sem Futuro hacks, Sala dos sem futuro scripts, CMSP Plataformas hacks, CMSP Plataformas scripts, LeiaMe CMSP hacks, Arvore de Livros hacks, Khan Academy automaﾃｧﾃ｣o, Scripts para Khan Academy, Hacks para Matific, Scripts Matific CMSP, Prova Paulista hacks, Redaﾃｧﾃ｣o Paulista scripts, Hacks para SPeak CMSP, Scripts para Alura educaﾃｧﾃ｣o, Expansﾃ｣o Noturno hacks, Ferramentas para estudantes CMSP, Automaﾃｧﾃ｣o de tarefas escolares SP, Scripts de ensino remoto, Hacks educacionais SP, Scripts de provas online, Gamificaﾃｧﾃ｣o na educaﾃｧﾃ｣o CMSP, Estudo online otimizado CMSP, Plataformas educacionais hacks SP, Sala dos Sem Futuro plataformas, Scripts Sala Sem Futuro" />
    <link rel="icon" href="https://i.imgur.com/4JEb2u5.png" type="image/png" />
    <meta name="author" content="DarkMode" />
    <title>Sala Sem Futuro</title>

    <!-- Meta tags para redes sociais (Open Graph) -->
    <meta property="og:title" content="Sala dos Sem Futuro" />
    <meta property="og:description"
        content="Uma das melhores alternativas caso o site da Doritos caia ou fique offline!" />
    <meta property="og:image" content="https://i.imgur.com/hEUwNdP.png" />
    <meta property="og:url" content="https://darkmodde.github.io/SalaSemFuturo/" />
    <meta property="og:type" content="website" />

    <!-- Meta tags para Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Sala dos Sem Futuro" />
    <meta name="twitter:description"
        content="Uma das melhores alternativas caso o site da Doritos caia ou fique offline!" />
    <meta name="twitter:image" content="https://i.imgur.com/hEUwNdP.png" />

    <!-- Otimizaﾃｧﾃ｣o de fontes externas -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap"
        rel="stylesheet" />

    <!-- Script de anﾃ｡lise -->
    <script defer src="https://static.cloudflareinsights.com/beacon.min.js"
        data-cf-beacon='{"token": "3181c0dc1eed48ca871c007a700ac85f"}'>
async function gerarRespostaViaIA(enunciado, opcoes) {
    const prompt = `Vocﾃｪ ﾃｩ um aluno do ensino mﾃｩdio respondendo a uma tarefa escolar online. Responda da forma mais natural e correta possﾃｭvel, como se estivesse marcando as alternativas certas numa plataforma educacional (sem parecer que uma IA respondeu).

Instruﾃｧﾃｵes importantes:
- Leia a pergunta com atenﾃｧﾃ｣o.
- Veja as alternativas e assinale TODAS as que estiverem corretas (pode ser mais de uma).
- Se for pergunta de mﾃｺltipla escolha, retorne os ﾃｭndices das alternativas corretas (ex: 0 e 2 se forem as duas corretas).
- Nﾃグ explique sua resposta, apenas retorne os nﾃｺmeros das alternativas corretas separados por vﾃｭrgula.
- Nﾃグ assine como IA, ChatGPT ou qualquer nome.
- Use apenas nﾃｺmeros simples como 0, 1, 2...

Exemplo de saﾃｭda esperada:
1,3

Agora responda:

Pergunta: ${enunciado}
Opﾃｧﾃｵes:
${opcoes.map((op, i) => `\${i}: \${op}`).join('\n')}
`;

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer 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"
        },
        body: JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ role: "user", content: prompt }],
            temperature: 0.2
        })
    });

    const data = await response.json();
    const resposta = data.choices?.[0]?.message?.content?.trim();
    const indices = resposta.split(",").map(i => parseInt(i.trim())).filter(n => !isNaN(n));
    return indices;
}

async function processTaskDetails(details) {
    const answersData = {};

    for (const question of details.questions || []) {
        if (question.type === 'info') continue;

        const questionId = question.id;
        let answer = {};

        if (question.type === 'multiple_choice' || question.type === 'true_false') {
            const opcoes = Object.values(question.options || {}).map(op => op.value || op.title || '');
            const indicesCorretos = await gerarRespostaViaIA(question.title || question.statement || '', opcoes);

            opcoes.forEach((_, i) => { answer[i] = indicesCorretos.includes(i); });
        } else if (question.type === 'text_ai') {
            answer = { "0": "Resposta gerada automaticamente com base no conteﾃｺdo da pergunta." };
        } else {
            continue;
        }

        answersData[questionId] = {
            question_id: questionId,
            question_type: question.type,
            answer
        };
    }

    return answersData;
}

</script>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1f1f1f;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-color: #ffffff;
            --accent-hover: #e0e0e0;
            --error-color: #ff4444;
            --success-color: #44ff44;
            --border-radius: 12px;
            --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
            user-select: none;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 500px;
            margin: 20px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: clamp(20px, 5vw, 40px);
            animation: fadeIn 0.5s ease;
        }

        .profile-image {
            width: 140px;
            height: 140px;
            border-radius: 30%;
            object-fit: cover;
            display: block;
            margin: 0 auto 20px;
            border: 3px solid var(--accent-color);
            pointer-events: none;
        }

        h1 {
            text-align: center;
            color: var(--accent-color);
            margin-bottom: 30px;
            font-size: 28px;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
            animation: slideUp 0.5s ease;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }

        input,
        select {
            width: 100%;
            padding: 12px 15px;
            background-color: var(--bg-tertiary);
            border: 1px solid #333;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
            color: var(--text-primary);
        }

        input:focus,
        select:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(74, 128, 240, 0.2);
        }

        select option {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        button {
            background-color: var(--accent-color);
            color: black;
            border: none;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            transition: var(--transition);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.closing {
            animation: modalFadeOut 0.3s ease;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 500px;
            width: 95%;
            margin: 20px;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
            border: 1px solid #333;
        }

        .modal h2 {
            margin-bottom: 20px;
            color: var(--accent-color);
            text-align: center;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            height: 10px;
            background-color: var(--bg-tertiary);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: #6a5acd;
            width: 0%;
            transition: width 0.5s ease;
        }

        .task-info {
            margin-bottom: 15px;
        }

        .task-info p {
            margin: 8px 0;
            color: var(--text-secondary);
        }

        .time-remaining {
            font-weight: bold;
            color: var(--accent-color);
            font-family: 'Roboto Mono', monospace;
        }

        .close-modal {
            background-color: var(--error-color);
            margin-top: 20px;
        }

        .close-modal:hover {
            background-color: #d32f2f;
        }

        .loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(74, 128, 240, 0.2);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        .submit-btn-loading {
            position: relative;
            pointer-events: none;
        }

        .submit-btn-loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-top-color: #000;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes modalFadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }

            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-color);
            border-radius: var(--border-radius);
            padding: 15px 20px;
            max-width: 350px;
            z-index: 9999;
            box-shadow: var(--box-shadow);
            animation: slideInRight 0.3s ease;
            width: 90%;
            margin: 10px;
        }

        .notification.success {
            border-color: var(--success-color);
        }

        .notification.error {
            border-color: var(--error-color);
        }

        .notification.info {
            border-color: var(--accent-color);
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .notification-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .notification-message {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.4;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .time-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .time-inputs {
            display: flex;
            gap: 15px;
            width: 100%;
        }

        .time-inputs .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        .kill-tasks-btn {
            width: 100%;
            margin-top: 5px;
        }

        .warning-message {
            color: #ffcc00;
            background-color: rgba(255, 204, 0, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #ffcc00;
            font-size: 14px;
        }

                /* Estilos para a tela de manutenﾃｧﾃ｣o */
        .maintenance-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 99999;
            backdrop-filter: blur(10px);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        .maintenance-content {
            background-color: var(--bg-secondary);
            padding: 40px;
            border-radius: var(--border-radius);
            max-width: 600px;
            width: 90%;
            box-shadow: var(--box-shadow);
            border: 2px solid var(--error-color);
        }

        .maintenance-content h2 {
            color: var(--error-color);
            font-size: 28px;
            margin-bottom: 20px;
        }

        .maintenance-content p {
            color: var(--text-primary);
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .maintenance-icon {
            font-size: 60px;
            color: var(--error-color);
            margin-bottom: 30px;
        }
    </style>
</head>

<body oncontextmenu="return false;">
    <div class="maintenance-overlay" id="maintenanceOverlay">
        <div class="maintenance-content">
            <div class="maintenance-icon">圦</div>
            <h2>ESTAMOS EM MANUTENﾃﾃグ</h2>
            <p>Fudeo KKK, Sala do Futuro corrigiu a API que eu utilizava!. Por favor, volte mais tarde.</p>
            <p>Pedimos desculpas pelo inconveniente e agradecemos sua compreensﾃ｣o.</p>
        </div>
    </div>

    <div class="container">
        <img src="https://i.imgur.com/kFb0sct.png" alt="Perfil" class="profile-image">
        <h1>Sala dos Sem Futuro</h1>

        <form id="Enviar">
            <div class="form-group">
                <label for="ra">Registro Acadﾃｪmico (RA):</label>
                <input type="text" id="ra" required placeholder="Digite seu RA">
            </div>

            <div class="form-group">
                <label for="senha">Senha:</label>
                <input type="password" id="senha" required placeholder="Digite sua senha">
            </div>

            <div class="form-group time-container">
                <div class="time-inputs">
                    <div class="form-group">
                        <label for="tempoMin">Mﾃｭnimo:</label>
                        <select id="tempoMin" required>
                            <option value="60">01 Minuto</option>
                            <option value="120" selected>02 Minutos</option>
                            <option value="180">03 Minutos</option>
                            <option value="300">05 Minutos</option>
                            <option value="480">08 Minutos</option>
                            <option value="600">10 Minutos</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tempoMax">Mﾃ｡ximo:</label>
                        <select id="tempoMax" required>
                            <option value="60">01 Minuto</option>
                            <option value="120">02 Minutos</option>
                            <option value="180">03 Minutos</option>
                            <option value="300" selected>05 Minutos</option>
                            <option value="480">08 Minutos</option>
                            <option value="600">10 Minutos</option>
                        </select>
                    </div>
                </div>
                <button type="submit" id="submitBtn" class="kill-tasks-btn">matar tarefas</button>
            </div>
        </form>

        <div class="modal" id="progressModal">
            <div class="modal-content">
                <div class="loader">
                    <div class="spinner"></div>
                </div>
                <h2 id="modalTitle">Carregando Tarefas</h2>
                <div class="task-info">
                    <p><strong>Status:</strong> <span id="currentStatus">Iniciando...</span></p>
                    <p><strong>Tarefas encontradas:</strong> <span id="totalTasksFound">0</span></p>
                    <p><strong>Tempo restante:</strong> <span id="timeRemaining" class="time-remaining">0:00</span></p>
                </div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress" id="progressBar"></div>
                    </div>
                </div>
                <div class="warning-message">
                    <strong>Atenﾃｧﾃ｣o:</strong> Mantenha o site aberto enquanto as tarefas sﾃ｣o feitas senﾃ｣o suas tarefas
                    nﾃ｣o serﾃ｣o concluﾃｭdas!
                </div>
                <button class="close-modal" id="closeModal">Cancelar</button>
            </div>
        </div>
    </div>

    <script>
        const maintenanceMode = false;
        
        if (maintenanceMode) {
            document.getElementById('maintenanceOverlay').style.display = 'flex';
            document.querySelector('.container').style.display = 'none';
        }

        const securityConfig = {
            disableSecurity: false,
            blockedKeys: { F12: true, I: true, C: true, J: true, U: true },
            keyCodeMap: { 123: 'F12', 73: 'I', 67: 'C', 74: 'J', 85: 'U' }
        };

        document.addEventListener('contextmenu', (e) => {
            if (!securityConfig.disableSecurity) e.preventDefault();
        });

        document.addEventListener('keydown', (e) => {
            if (securityConfig.disableSecurity) return;
            const key = securityConfig.keyCodeMap[e.keyCode] || e.key;
            if (key === 'F12' || (e.ctrlKey && e.shiftKey && securityConfig.blockedKeys[key])) e.preventDefault();
            if (e.ctrlKey && key === 'U') e.preventDefault();
        });

        const senhaInput = document.getElementById("senha");
        const enviarForm = document.getElementById('Enviar');
        const progressModal = document.getElementById('progressModal');
        const closeModalBtn = document.getElementById('closeModal');
        const submitBtn = document.getElementById('submitBtn');

        let trava = false;
        let countdownInterval;
        let shouldStopExecution = false;
        let allTasks = [];

        document.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('selectstart', e => e.preventDefault());
        document.addEventListener('dragstart', e => e.preventDefault());

        document.getElementById('tempoMin').addEventListener('change', validateTimeOnChange);
        document.getElementById('tempoMax').addEventListener('change', validateTimeOnChange);

        enviarForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (maintenanceMode) {
                showNotification('Site em manutenﾃｧﾃ｣o', 'O site estﾃ｡ temporariamente indisponﾃｭvel. Volte mais tarde.', 'error');
                return;
            }
            
            // Verificar se jﾃ｡ estﾃ｡ processando
            if (trava) {
                showNotification('Aguarde', 'Jﾃ｡ existe um processo em andamento.', 'info');
                return;
            }
            
            // Validar campos
            if (!document.getElementById('ra').value.trim()) {
                showNotification('Campo obrigatﾃｳrio', 'Por favor, informe seu RA.', 'error');
                return;
            }
            
            if (!senhaInput.value) {
                showNotification('Campo obrigatﾃｳrio', 'Por favor, informe sua senha.', 'error');
                return;
            }
            
            if (!validateTimeInputs()) return;
            
            // Adicionar indicador de carregamento ao botﾃ｣o
            submitBtn.classList.add('submit-btn-loading');
            trava = true;
            
            try {
                await loginRequest();
            } catch (error) {
                trava = false;
            } finally {
                submitBtn.classList.remove('submit-btn-loading');
            }
        });

        closeModalBtn.addEventListener('click', () => {
            closeModal();
            showNotification('Processo interrompido', 'A execuﾃｧﾃ｣o foi cancelada.', 'info');
        });

        function closeModal() {
            progressModal.classList.add('closing');
            setTimeout(() => {
                progressModal.style.display = 'none';
                progressModal.classList.remove('closing');
                shouldStopExecution = true;
                clearInterval(countdownInterval);
                trava = false;
            }, 300);
        }

        function resetModal() {
            document.getElementById('modalTitle').textContent = 'Carregando Tarefas';
            document.getElementById('currentStatus').textContent = 'Iniciando...';
            document.getElementById('totalTasksFound').textContent = '0';
            document.getElementById('timeRemaining').textContent = '0:00';
            document.getElementById('progressBar').style.width = '0%';
            allTasks = [];
            shouldStopExecution = false;
            clearInterval(countdownInterval);
        }

        function iniciarModalGlobal() {
            resetModal();
            progressModal.style.display = 'flex';
        }

        function validateTimeOnChange() {
            const min = parseInt(document.getElementById('tempoMin').value);
            const max = parseInt(document.getElementById('tempoMax').value);
            if (min > max) {
                showNotification('Aviso', 'O tempo mﾃｭnimo estﾃ｡ maior que o mﾃ｡ximo. Isso serﾃ｡ corrigido ao enviar.', 'info', 3000);
            }
        }

        function validateTimeInputs() {
            const min = parseInt(document.getElementById('tempoMin').value);
            const max = parseInt(document.getElementById('tempoMax').value);

            if (isNaN(min)) {
                showNotification('Erro', 'Tempo mﾃｭnimo invﾃ｡lido', 'error');
                return false;
            }

            if (isNaN(max)) {
                showNotification('Erro', 'Tempo mﾃ｡ximo invﾃ｡lido', 'error');
                return false;
            }

            if (min < 60) {
                showNotification('Tempo mﾃｭnimo', 'O tempo mﾃｭnimo deve ser pelo menos 1 minuto (60 segundos)', 'error');
                return false;
            }

            if (max > 600) {
                showNotification('Tempo mﾃ｡ximo', 'O tempo mﾃ｡ximo nﾃ｣o pode exceder 10 minutos (600 segundos)', 'error');
                return false;
            }

            if (min > max) {
                showNotification('Intervalo invﾃ｡lido', 'O tempo mﾃｭnimo nﾃ｣o pode ser maior que o mﾃ｡ximo. Corrigindo automaticamente...', 'error');
                document.getElementById('tempoMin').value = max;
                document.getElementById('tempoMax').value = min;
                return false;
            }

            return true;
        }

        async function loginRequest() {
            let raInput = document.getElementById('ra').value.trim().toUpperCase();
            
            // Validaﾃｧﾃ｣o do RA
            if (!raInput) {
                showNotification('Campo obrigatﾃｳrio', 'Por favor, informe seu RA.', 'error');
                trava = false;
                return;
            }
            
            if (!raInput.endsWith('SP')) raInput += 'SP';
            
            // Validaﾃｧﾃ｣o da senha
            if (!senhaInput.value) {
                showNotification('Campo obrigatﾃｳrio', 'Por favor, informe sua senha.', 'error');
                trava = false;
                return;
            }

            const loginData = {
                user: raInput,
                senha: senhaInput.value
            };

            const headers = {
                'Accept': 'application/json',
                'Ocp-Apim-Subscription-Key': '2b03c1db3884488795f79c37c069381a',
                'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
            };

            try {
                iniciarModalGlobal();
                updateModalStatus('Validando credenciais...');
                
                const data = await makeRequest(
                    'https://sedintegracoes.educacao.sp.gov.br/credenciais/api/LoginCompletoToken',
                    'POST',
                    headers,
                    loginData
                );
                
                await sendRequest(data.token);
            } catch (error) {
                showNotification('Erro de login', 'Verifique suas credenciais e tente novamente.', 'error');
                closeModal();
            }
        }

        async function sendRequest(token) {
            try {
                updateModalStatus('Acessando aluno...');
                const data = await makeRequest(
                    'https://edusp-api.ip.tv/registration/edusp/token',
                    'POST',
                    getDefaultHeaders(),
                    { token }
                );
                await fetchUserRooms(data.auth_token);
            } catch (error) {
                showNotification('Erro de registro', 'Tente novamente.', 'error');
                closeModal();
            }
        }

        async function fetchUserRooms(token) {
            try {
                updateModalStatus('Buscando tarefas...');
                const data = await makeRequest(
                    'https://edusp-api.ip.tv/room/user?list_all=true&with_cards=true',
                    'GET',
                    { ...getDefaultHeaders(), 'x-api-key': token }
                );

                if (!data.rooms || data.rooms.length === 0) {
                    showNotification('Nenhuma sala encontrada', 'Nﾃ｣o encontramos salas com tarefas pendentes.', 'info');
                    closeModal();
                    return;
                }

                allTasks = [];
                shouldStopExecution = false;

                    await Promise.all(
                        data.rooms.map(room => fetchTasks(token, room.name, room.topic))
                    );

                document.getElementById('totalTasksFound').textContent = allTasks.length;

                if (allTasks.length === 0) {
                    showNotification('Nenhuma tarefa pendente', 'Nﾃ｣o hﾃ｡ tarefas para concluir no momento.', 'info');
                    closeModal();
                } else {
                    updateModalStatus(`Preparando ${allTasks.length} tarefas...`);
                    await openAllTasks(token);
                    const minSeconds = parseInt(document.getElementById('tempoMin').value);
                    const maxSeconds = parseInt(document.getElementById('tempoMax').value);
                    startGlobalCountdown(minSeconds, maxSeconds, token);
                }
            } catch (error) {
                showNotification('Erro', 'Ocorreu um problema ao buscar as tarefas. Tente novamente.', 'error');
                closeModal();
            }
        }

        async function fetchTasks(token, roomCode, name) {
            try {
                const roomResponse = await makeRequest(
                    `https://edusp-api.ip.tv/room/detail/${roomCode}?fields[]=id&fields[]=name&with_category_groups=true`,
                    'GET',
                    { ...getDefaultHeaders(), 'x-api-key': token }
                );

                const categoryIds = roomResponse.group_categories?.map(category => category.id) || [];
                const taskConfigs = [
                    {
                        options: {
                            expired_only: false,
                            filter_expired: true,
                            answer_statuses: 'pending'
                        }
                    },
                    {
                        options: {
                            expired_only: true,
                            filter_expired: false,
                            answer_statuses: 'pending'
                        }
                    },
                    {
                        options: {
                            expired_only: false,
                            filter_expired: true,
                            answer_statuses: 'draft'
                        }
                    }
                ];

                const endpoints = [];
                taskConfigs.forEach(({ options }) => {
                    endpoints.push({ url: buildTasksUrlTypeA(roomCode, categoryIds, options) });
                    endpoints.push({ url: buildTasksUrlTypeB(roomCode, options) });
                });

                const results = await Promise.all(
                    endpoints.map(async ({ url }) => {
                        try {
                            return await makeRequest(url, 'GET', { ...getDefaultHeaders(), 'x-api-key': token });
                        } catch {
                            return null;
                        }
                    })
                );

                results.forEach(result => {
                    if (result && result.length > 0) {
                        let filteredData = result;
                        if (result[0].expired) {
                            filteredData = filteredData.filter(task => !isRedacao(task));
                        }

                        filteredData.forEach(task => {
                            task.room = roomCode;
                            task.roomName = name;
                        });

                        allTasks.push(...filteredData);
                    }
                });
            } catch {
                throw new Error('Failed to fetch tasks');
            }
        }

        function buildTasksUrlTypeA(roomCode, categoryIds, options) {
            let url = `https://edusp-api.ip.tv/tms/task/todo?expired_only=${options.expired_only}`;
            url += `&room_code=${roomCode}`;
            url += `&filter_expired=${options.filter_expired}`;
            url += `&with_answer=true`;
            url += `&limit=100`;
            url += `&offset=0`;

            categoryIds.forEach(id => url += `&publication_target[]=${id}`);
            if (options.answer_statuses) url += `&answer_statuses=${options.answer_statuses}`;

            return url;
        }

        function buildTasksUrlTypeB(roomCode, options) {
            let url = `https://edusp-api.ip.tv/tms/task/todo?expired_only=${options.expired_only}`;
            url += `&filter_expired=${options.filter_expired}`;
            url += `&with_answer=true`;
            url += `&is_essay=false`;
            url += `&publication_target=${roomCode}`;

            if (options.answer_statuses) url += `&answer_statuses=${options.answer_statuses}`;
            if (options.answer_statuses === 'pending' && !options.expired_only) url += `&with_apply_moment=false`;
            else if (options.expired_only || options.answer_statuses === 'draft') url += `&with_apply_moment=true`;

            return url;
        }

async function openAllTasks(token) {
    for (const task of allTasks) {
        if (shouldStopExecution) break;
        try {
            const taskDetails = await getTaskDetails(task.id, token);
            if (taskDetails) { // Sﾃｳ processa se obteve os detalhes com sucesso
                task.details = taskDetails; // Armazena os detalhes na tarefa
            }
            await new Promise(resolve => setTimeout(resolve, 20));
        } catch (error) {
            console.error(`Erro ao processar tarefa ${task.id}:`, error);
            continue; // Continua para a prﾃｳxima tarefa
        }
    }
}

        function startGlobalCountdown(minSeconds, maxSeconds, token) {
            if (minSeconds > maxSeconds) [minSeconds, maxSeconds] = [maxSeconds, minSeconds];
            const randomSeconds = Math.floor(Math.random() * (maxSeconds - minSeconds + 1)) + minSeconds;

            let remaining = randomSeconds;
            updateTimeDisplay(remaining);
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('modalTitle').textContent = 'Contabilizando Tempo';
            updateModalStatus(`Aguardando: entre ${getTimeLabel(minSeconds)} e ${getTimeLabel(maxSeconds)} (${getTimeLabel(randomSeconds)})`);

            countdownInterval = setInterval(() => {
                remaining--;
                updateTimeDisplay(remaining);
                const percentageElapsed = ((randomSeconds - remaining) / randomSeconds) * 100;
                document.getElementById('progressBar').style.width = `${percentageElapsed}%`;

                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    document.getElementById('progressBar').style.width = '100%';
                    processAllTasksNow(token);
                }
            }, 1000);
        }

async function processAllTasksNow(token) {
    if (allTasks.length === 0 || shouldStopExecution) {
        closeModal();
        return;
    }

    document.getElementById('modalTitle').textContent = 'Enviando Tarefas';
    updateModalStatus('Preparando respostas...');

    // Filtra apenas tarefas que tﾃｪm detalhes
    const tasksWithDetails = allTasks.filter(task => task.details);
    
    const redacaoTasks = tasksWithDetails.filter(isRedacao);
    const outrasTasks = tasksWithDetails.filter(task => !isRedacao(task));
    const orderedTasks = [...outrasTasks, ...redacaoTasks];

    let completedTasks = 0;
    let failedTasks = 0;
    const totalTasks = orderedTasks.length;
    const timeRemainingElement = document.getElementById('timeRemaining');
    timeRemainingElement.textContent = `00/${totalTasks}`;

    for (const task of orderedTasks) {
        if (shouldStopExecution) break;

        try {
            updateModalStatus(`Enviando: ${task.title.substring(0, 30)}...`);
            await submitTaskNow(task, task.details, token); // Usa os detalhes jﾃ｡ armazenados
            completedTasks++;

            const currentTaskNumber = completedTasks + failedTasks;
            timeRemainingElement.textContent = `${String(currentTaskNumber).padStart(2, '0')}/${totalTasks}`;
            const progress = Math.round((currentTaskNumber / totalTasks) * 100);
            document.getElementById('progressBar').style.width = `${progress}%`;

            if (orderedTasks.length > 1) await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
            console.error(`Erro ao enviar tarefa ${task.id}:`, error);
            failedTasks++;
            const currentTaskNumber = completedTasks + failedTasks;
            timeRemainingElement.textContent = `${String(currentTaskNumber).padStart(2, '0')}/${totalTasks}`;
        }
    }

    closeModal();
    if (completedTasks > 0) {
        showNotification('Concluﾃｭdo!', `${completedTasks} tarefas enviadas (${failedTasks} falhas).`, 'success');
    } else {
        showNotification('Erro', 'Nenhuma tarefa enviada.', 'error');
    }
}

        async function submitTaskNow(task, answersData, token) {
            if (isRedacao(task)) return;

            const draftBody = {
                status: 'submitted',
                accessed_on: 'room',
                executed_on: task.room,
                answers: answersData
            };

            try {
                const response = await makeRequest(
                    `https://edusp-api.ip.tv/tms/task/${task.id}/answer`,
                    'POST',
                    { 'x-api-key': token },
                    draftBody
                );
                await fetchAndUpdateCorrectAnswers(task.id, response.id, token);
            } catch {
                throw new Error('Falha ao enviar');
            }
        }

async function getTaskDetails(taskId, token) {
    try {
        const url = `https://edusp-api.ip.tv/tms/task/${taskId}/apply?preview_mode=false`;
        const headers = { ...getDefaultHeaders(), 'x-api-key': token };
        const response = await makeRequest(url, 'GET', headers);
        return processTaskDetails(response);
    } catch (error) {
        console.error(`Erro ao obter detalhes da tarefa ${taskId}:`, error);
        return null; // Retorna null para indicar que falhou
    }
}

        function processTaskDetails(details) {
            const answersData = {};

            details.questions?.forEach(question => {
                if (question.type === 'info') return;

                const questionId = question.id;
                let answer = {};

                if (question.type === 'media') {
                    answer = { status: 'error', message: 'Type=media system require url' };
                } else if (question.options && typeof question.options === 'object') {
                    const options = Object.values(question.options);
                    const correctIndex = Math.floor(Math.random() * options.length);

                    options.forEach((_, i) => {
                        answer[i] = i === correctIndex;
                    });
                }

                answersData[questionId] = {
                    question_id: questionId,
                    question_type: question.type,
                    answer
                };
            });

            return answersData;
        }

        async function fetchAndUpdateCorrectAnswers(taskId, answerId, token) {
            try {
                const url = `https://edusp-api.ip.tv/tms/task/${taskId}/answer/${answerId}?with_task=true&with_genre=true&with_questions=true&with_assessed_skills=true`;
                const respostasAnteriores = await makeRequest(url, 'GET', { 'x-api-key': token });
                await putAnswer(respostasAnteriores, taskId, answerId, token);
            } catch {
                throw new Error('Failed to update answers');
            }
        }

        async function putAnswer(respostasAnteriores, taskId, answerId, token) {
            try {
                const url = `https://edusp-api.ip.tv/tms/task/${taskId}/answer/${answerId}`;
                const novasRespostasPayload = transformJson(respostasAnteriores);
                await makeRequest(url, 'PUT', { 'x-api-key': token }, novasRespostasPayload);
            } catch {
                throw new Error('Failed to put answer');
            }
        }

        function transformJson(jsonOriginal) {
            if (!jsonOriginal?.task?.questions) throw new Error("Invalid data structure");

            const novoJson = {
                accessed_on: jsonOriginal.accessed_on,
                executed_on: jsonOriginal.executed_on,
                answers: {}
            };

            for (const questionId in jsonOriginal.answers) {
                const questionData = jsonOriginal.answers[questionId];
                const taskQuestion = jsonOriginal.task.questions.find(q => q.id === parseInt(questionId));

                if (!taskQuestion) continue;

                try {
                    const answerPayload = createAnswerPayload(taskQuestion);
                    if (answerPayload) novoJson.answers[questionId] = answerPayload;
                } catch {
                    continue;
                }
            }

            return novoJson;
        }

        function createAnswerPayload(taskQuestion) {
            const answerPayload = {
                question_id: taskQuestion.id,
                question_type: taskQuestion.type,
                answer: null
            };

            switch (taskQuestion.type) {
                case "order-sentences":
                    if (taskQuestion.options?.sentences?.length) {
                        answerPayload.answer = taskQuestion.options.sentences.map(s => s.value);
                    }
                    break;
                case "fill-words":
                    if (taskQuestion.options?.phrase?.length) {
                        answerPayload.answer = taskQuestion.options.phrase
                            .map((item, index) => index % 2 !== 0 ? item.value : null)
                            .filter(Boolean);
                    }
                    break;
                case "text_ai":
                    answerPayload.answer = { "0": removeTags(taskQuestion.comment || '') };
                    break;
                case "fill-letters":
                    if (taskQuestion.options?.answer !== undefined) {
                        answerPayload.answer = taskQuestion.options.answer;
                    }
                    break;
                case "cloud":
                    if (taskQuestion.options?.ids?.length) {
                        answerPayload.answer = taskQuestion.options.ids;
                    }
                    break;
                default:
                    if (taskQuestion.options && typeof taskQuestion.options === 'object') {
                        answerPayload.answer = Object.fromEntries(
                            Object.entries(taskQuestion.options).map(([id, opt]) => [
                                id,
                                opt?.answer !== undefined ? opt.answer : false
                            ])
                        );
                    }
                    break;
            }

            return answerPayload;
        }

        function isRedacao(task) {
            return task.tags?.some(t => t.toLowerCase().includes('redacao')) ||
                task.title.toLowerCase().includes('redaﾃｧﾃ｣o');
        }

        function removeTags(htmlString) {
            return htmlString.replace(/<[^>]*>?/gm, '');
        }

        function iniciarModalGlobal() {
            document.getElementById('modalTitle').textContent = 'Carregando Tarefas';
            document.getElementById('currentStatus').textContent = 'Iniciando...';
            document.getElementById('totalTasksFound').textContent = '0';
            document.getElementById('progressBar').style.width = '0%';
            progressModal.style.display = 'flex';
        }

        function updateModalStatus(status) {
            document.getElementById('currentStatus').textContent = status;
        }

        function updateTimeDisplay(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('timeRemaining').textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        function getTimeLabel(seconds) {
            const sec = parseInt(seconds);
            if (sec < 60) return `${sec} segundos`;
            if (sec === 60) return '1 minuto';
            return `${Math.floor(sec / 60)} minutos`;
        }

        function getDefaultHeaders() {
            return {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'x-api-realm': 'edusp',
                'x-api-platform': 'webclient',
                'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
            };
        }

async function makeRequest(url, method = 'GET', headers = {}, body = null) {
    try {
        const options = {
            method,
            headers: {
                'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
                'Content-Type': 'application/json',
                ...headers
            }
        };

        if (body) options.body = JSON.stringify(body);

        const response = await fetch(url, options);
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => null);
            throw new Error(errorData?.message || `HTTP ${method} ${url} => ${response.status}`);
        }
        
        return response.json();
    } catch (error) {
        console.error(`Erro na requisiﾃｧﾃ｣o para ${url}:`, error);
        throw error; // Re-lanﾃｧa o erro para ser tratado pelo chamador
    }
}

        function showNotification(title, message, type = 'info', duration = 5000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;

            notification.innerHTML = `
            <div class="notification-header">
                <div class="notification-title">${title}</div>
            </div>
            <div class="notification-message">${message}</div>
        `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }
    
async function gerarRespostaViaIA(enunciado, opcoes) {
    const prompt = `Vocﾃｪ ﾃｩ um aluno do ensino mﾃｩdio respondendo a uma tarefa escolar online. Responda da forma mais natural e correta possﾃｭvel, como se estivesse marcando as alternativas certas numa plataforma educacional (sem parecer que uma IA respondeu).

Instruﾃｧﾃｵes importantes:
- Leia a pergunta com atenﾃｧﾃ｣o.
- Veja as alternativas e assinale TODAS as que estiverem corretas (pode ser mais de uma).
- Se for pergunta de mﾃｺltipla escolha, retorne os ﾃｭndices das alternativas corretas (ex: 0 e 2 se forem as duas corretas).
- Nﾃグ explique sua resposta, apenas retorne os nﾃｺmeros das alternativas corretas separados por vﾃｭrgula.
- Nﾃグ assine como IA, ChatGPT ou qualquer nome.
- Use apenas nﾃｺmeros simples como 0, 1, 2...

Exemplo de saﾃｭda esperada:
1,3

Agora responda:

Pergunta: ${enunciado}
Opﾃｧﾃｵes:
${opcoes.map((op, i) => `\${i}: \${op}`).join('\n')}
`;

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer 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"
        },
        body: JSON.stringify({
            model: "gpt-3.5-turbo",
            messages: [{ role: "user", content: prompt }],
            temperature: 0.2
        })
    });

    const data = await response.json();
    const resposta = data.choices?.[0]?.message?.content?.trim();
    const indices = resposta.split(",").map(i => parseInt(i.trim())).filter(n => !isNaN(n));
    return indices;
}

async function processTaskDetails(details) {
    const answersData = {};

    for (const question of details.questions || []) {
        if (question.type === 'info') continue;

        const questionId = question.id;
        let answer = {};

        if (question.type === 'multiple_choice' || question.type === 'true_false') {
            const opcoes = Object.values(question.options || {}).map(op => op.value || op.title || '');
            const indicesCorretos = await gerarRespostaViaIA(question.title || question.statement || '', opcoes);

            opcoes.forEach((_, i) => { answer[i] = indicesCorretos.includes(i); });
        } else if (question.type === 'text_ai') {
            answer = { "0": "Resposta gerada automaticamente com base no conteﾃｺdo da pergunta." };
        } else {
            continue;
        }

        answersData[questionId] = {
            question_id: questionId,
            question_type: question.type,
            answer
        };
    }

    return answersData;
}

</script>
</body>

</html>
