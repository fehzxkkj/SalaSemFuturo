<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Uma das melhores alternativas caso o site da Doritos caia ou fique offline!" />
    <meta name="author" content="DarkMode" />
    <link rel="icon" href="https://i.imgur.com/4JEb2u5.png" type="image/png" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://darkmodde.github.io/SalaSemFuturo/" />
    <meta property="og:title" content="Sala dos Sem Futuro" />
    <meta property="og:description" content="Uma das melhores alternativas caso o site da Doritos caia ou fique offline!" />
    <meta property="og:image" content="https://i.imgur.com/hEUwNdP.png" />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Sala dos Sem Futuro" />
    <meta name="twitter:description" content="Uma das melhores alternativas caso o site da Doritos caia ou fique offline!" />
    <meta name="twitter:image" content="https://i.imgur.com/hEUwNdP.png" />

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet" />

    <!-- Cloudflare Analytics -->
    <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "3181c0dc1eed48ca871c007a700ac85f"}'></script>

    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1f1f1f;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-color: #ffffff;
            --accent-hover: #e0e0e0;
            --error-color: #ff4444;
            --success-color: #44ff44;
            --border-radius: 12px;
            --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
            user-select: none;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 500px;
            margin: 20px;
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: clamp(20px, 5vw, 40px);
            animation: fadeIn 0.5s ease;
        }

        .profile-image {
            width: 140px;
            height: 140px;
            border-radius: 30%;
            object-fit: cover;
            display: block;
            margin: 0 auto 20px;
            border: 3px solid var(--accent-color);
            pointer-events: none;
        }

        h1 {
            text-align: center;
            color: var(--accent-color);
            margin-bottom: 30px;
            font-size: 28px;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
            animation: slideUp 0.5s ease;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }

        input,
        select {
            width: 100%;
            padding: 12px 15px;
            background-color: var(--bg-tertiary);
            border: 1px solid #333;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
            color: var(--text-primary);
        }

        input:focus,
        select:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(74, 128, 240, 0.2);
        }

        select option {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        button {
            background-color: var(--accent-color);
            color: black;
            border: none;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            transition: var(--transition);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: var(--bg-secondary);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 500px;
            width: 95%;
            margin: 20px;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
            border: 1px solid #333;
        }

        .modal h2 {
            margin-bottom: 20px;
            color: var(--accent-color);
            text-align: center;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            height: 10px;
            background-color: var(--bg-tertiary);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: #6a5acd;
            width: 0%;
            transition: width 0.5s ease;
        }

        .task-info {
            margin-bottom: 15px;
        }

        .task-info p {
            margin: 8px 0;
            color: var(--text-secondary);
        }

        .time-remaining {
            font-weight: bold;
            color: var(--accent-color);
            font-family: 'Roboto Mono', monospace;
        }

        .close-modal {
            background-color: var(--error-color);
            margin-top: 20px;
        }

        .close-modal:hover {
            background-color: #d32f2f;
        }

        .loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(74, 128, 240, 0.2);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        .submit-btn-loading {
            position: relative;
            pointer-events: none;
        }

        .submit-btn-loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-top-color: #000;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-color);
            border-radius: var(--border-radius);
            padding: 15px 20px;
            max-width: 350px;
            z-index: 9999;
            box-shadow: var(--box-shadow);
            animation: slideInRight 0.3s ease;
            width: 90%;
            margin: 10px;
        }

        .notification.success {
            border-color: var(--success-color);
        }

        .notification.error {
            border-color: var(--error-color);
        }

        .notification.info {
            border-color: var(--accent-color);
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .notification-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .notification-message {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.4;
        }

        .time-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .time-inputs {
            display: flex;
            gap: 15px;
            width: 100%;
        }

        .time-inputs .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        .kill-tasks-btn {
            width: 100%;
            margin-top: 5px;
        }

        .warning-message {
            color: #ffcc00;
            background-color: rgba(255, 204, 0, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #ffcc00;
            font-size: 14px;
        }

        .maintenance-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 99999;
            backdrop-filter: blur(10px);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        .maintenance-content {
            background-color: var(--bg-secondary);
            padding: 40px;
            border-radius: var(--border-radius);
            max-width: 600px;
            width: 90%;
            box-shadow: var(--box-shadow);
            border: 2px solid var(--error-color);
        }

        .maintenance-content h2 {
            color: var(--error-color);
            font-size: 28px;
            margin-bottom: 20px;
        }

        .maintenance-content p {
            color: var(--text-primary);
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .maintenance-icon {
            font-size: 60px;
            color: var(--error-color);
            margin-bottom: 30px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>

<body>
    <div class="maintenance-overlay" id="maintenanceOverlay">
        <div class="maintenance-content">
            <div class="maintenance-icon">üöß</div>
            <h2>ESTAMOS EM MANUTEN√á√ÉO</h2>
            <p>Fudeo KKK, Sala do Futuro corrigiu a API que eu utilizava!. Por favor, volte mais tarde.</p>
            <p>Pedimos desculpas pelo inconveniente e agradecemos sua compreens√£o.</p>
        </div>
    </div>

    <div class="container">
        <img src="https://i.imgur.com/kFb0sct.png" alt="Perfil" class="profile-image">
        <h1>Sala dos Sem Futuro</h1>

        <form id="Enviar">
            <div class="form-group">
                <label for="ra">Registro Acad√™mico (RA):</label>
                <input type="text" id="ra" required placeholder="Digite seu RA">
            </div>

            <div class="form-group">
                <label for="senha">Senha:</label>
                <input type="password" id="senha" required placeholder="Digite sua senha">
            </div>

            <div class="form-group time-container">
                <div class="time-inputs">
                    <div class="form-group">
                        <label for="tempoMin">M√≠nimo:</label>
                        <select id="tempoMin" required>
                            <option value="60">01 Minuto</option>
                            <option value="120" selected>02 Minutos</option>
                            <option value="180">03 Minutos</option>
                            <option value="300">05 Minutos</option>
                            <option value="480">08 Minutos</option>
                            <option value="600">10 Minutos</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tempoMax">M√°ximo:</label>
                        <select id="tempoMax" required>
                            <option value="60">01 Minuto</option>
                            <option value="120">02 Minutos</option>
                            <option value="180">03 Minutos</option>
                            <option value="300" selected>05 Minutos</option>
                            <option value="480">08 Minutos</option>
                            <option value="600">10 Minutos</option>
                        </select>
                    </div>
                </div>
                
            </div>
        </form>

        <div class="modal" id="progressModal">
            <div class="modal-content">
                <div class="loader">
                    <div class="spinner"></div>
                </div>
                <h2 id="modalTitle">Carregando Tarefas</h2>
                <div class="task-info">
                    <p><strong>Status:</strong> <span id="currentStatus">Iniciando...</span></p>
                    <p><strong>Tarefas encontradas:</strong> <span id="totalTasksFound">0</span></p>
                    <p><strong>Tempo restante:</strong> <span id="timeRemaining" class="time-remaining">0:00</span></p>
                </div>
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress" id="progressBar"></div>
                    </div>
                </div>
                <div class="warning-message">
                    <strong>Aten√ß√£o:</strong> Mantenha o site aberto enquanto as tarefas s√£o feitas sen√£o suas tarefas
                    n√£o ser√£o conclu√≠das!
                </div>
                <button class="close-modal" id="closeModal">Cancelar</button>
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√µes iniciais
        const config = {
            maintenanceMode: false,
            security: {
                disableSecurity: false,
                blockedKeys: { F12: true, I: true, C: true, J: true, U: true },
                keyCodeMap: { 123: 'F12', 73: 'I', 67: 'C', 74: 'J', 85: 'U' }
            }
        };

        // Elementos DOM
        const elements = {
            maintenanceOverlay: document.getElementById('maintenanceOverlay'),
            container: document.querySelector('.container'),
            senhaInput: document.getElementById('senha'),
            enviarForm: document.getElementById('Enviar'),
            progressModal: document.getElementById('progressModal'),
            closeModalBtn: document.getElementById('closeModal'),
            submitBtn: document.getElementById('submitBtn'),
            modalTitle: document.getElementById('modalTitle'),
            currentStatus: document.getElementById('currentStatus'),
            totalTasksFound: document.getElementById('totalTasksFound'),
            timeRemaining: document.getElementById('timeRemaining'),
            progressBar: document.getElementById('progressBar')
        };

        // Estado da aplica√ß√£o
        const state = {
            trava: false,
            countdownInterval: null,
            shouldStopExecution: false,
            allTasks: []
        };

        // Inicializa√ß√£o
        function init() {
            console.log('[INIT] Inicializando aplica√ß√£o...');
            
            if (config.maintenanceMode) {
                console.log('[MAINTENANCE] Modo de manuten√ß√£o ativado');
                elements.maintenanceOverlay.style.display = 'flex';
                elements.container.style.display = 'none';
            }

            setupEventListeners();
        }

        // Configura√ß√£o de listeners
        function setupEventListeners() {
            console.log('[EVENTS] Configurando listeners...');
            
            // Preven√ß√£o de a√ß√µes do usu√°rio
            document.addEventListener('contextmenu', e => e.preventDefault());
            document.addEventListener('selectstart', e => e.preventDefault());
            document.addEventListener('dragstart', e => e.preventDefault());

            // Seguran√ßa
            document.addEventListener('keydown', handleKeyDown);

            // Formul√°rio
            document.getElementById('tempoMin').addEventListener('change', validateTimeOnChange);
            document.getElementById('tempoMax').addEventListener('change', validateTimeOnChange);
            elements.enviarForm.addEventListener('submit', handleFormSubmit);
            elements.closeModalBtn.addEventListener('click', closeModal);
        }

        // Handlers
        function handleKeyDown(e) {
            if (config.security.disableSecurity) return;
            
            const key = config.security.keyCodeMap[e.keyCode] || e.key;
            if (key === 'F12' || (e.ctrlKey && e.shiftKey && config.security.blockedKeys[key])) {
                e.preventDefault();
                console.warn('[SECURITY] Tentativa de abrir ferramentas de desenvolvimento bloqueada');
            }
            if (e.ctrlKey && key === 'U') e.preventDefault();
        }

        async function handleFormSubmit(e) {
            e.preventDefault();
            console.log('[FORM] Submiss√£o do formul√°rio iniciada');

            if (config.maintenanceMode) {
                showNotification('Site em manuten√ß√£o', 'O site est√° temporariamente indispon√≠vel. Volte mais tarde.', 'error');
                console.error('[MAINTENANCE] Tentativa de uso durante manuten√ß√£o');
                return;
            }
            
            if (state.trava) {
                showNotification('Aguarde', 'J√° existe um processo em andamento.', 'info');
                console.warn('[FORM] Tentativa de submiss√£o duplicada');
                return;
            }
            
            if (!validateForm()) return;
            
            elements.submitBtn.classList.add('submit-btn-loading');
            state.trava = true;
            
            try {
                console.log('[AUTH] Iniciando processo de login...');
                await loginRequest();
            } catch (error) {
                console.error('[AUTH] Erro no processo de login:', error);
                state.trava = false;
                elements.submitBtn.classList.remove('submit-btn-loading');
            }
        }

        // Valida√ß√µes
        function validateForm() {
            const raValue = document.getElementById('ra').value.trim();
            const senhaValue = elements.senhaInput.value;
            
            if (!raValue) {
                showNotification('Campo obrigat√≥rio', 'Por favor, informe seu RA.', 'error');
                console.error('[VALIDATION] RA n√£o informado');
                return false;
            }
            
            if (!senhaValue) {
                showNotification('Campo obrigat√≥rio', 'Por favor, informe sua senha.', 'error');
                console.error('[VALIDATION] Senha n√£o informada');
                return false;
            }
            
            if (!validateTimeInputs()) {
                console.error('[VALIDATION] Tempos inv√°lidos');
                return false;
            }
            
            return true;
        }

        function validateTimeOnChange() {
            const min = parseInt(document.getElementById('tempoMin').value);
            const max = parseInt(document.getElementById('tempoMax').value);
            
            if (min > max) {
                showNotification('Aviso', 'O tempo m√≠nimo est√° maior que o m√°ximo. Isso ser√° corrigido ao enviar.', 'info', 3000);
                console.warn('[VALIDATION] Tempo m√≠nimo maior que o m√°ximo');
            }
        }

        function validateTimeInputs() {
            const min = parseInt(document.getElementById('tempoMin').value);
            const max = parseInt(document.getElementById('tempoMax').value);

            if (isNaN(min) || isNaN(max)) {
                showNotification('Erro', 'Tempo inv√°lido', 'error');
                return false;
            }

            if (min < 60) {
                showNotification('Tempo m√≠nimo', 'O tempo m√≠nimo deve ser pelo menos 1 minuto (60 segundos)', 'error');
                return false;
            }

            if (max > 600) {
                showNotification('Tempo m√°ximo', 'O tempo m√°ximo n√£o pode exceder 10 minutos (600 segundos)', 'error');
                return false;
            }

            if (min > max) {
                showNotification('Intervalo inv√°lido', 'O tempo m√≠nimo n√£o pode ser maior que o m√°ximo. Corrigindo automaticamente...', 'error');
                document.getElementById('tempoMin').value = max;
                document.getElementById('tempoMax').value = min;
                return false;
            }

            return true;
        }

        // Fun√ß√µes de autentica√ß√£o
        async function loginRequest() {
            let raInput = document.getElementById('ra').value.trim().toUpperCase();
            
            if (!raInput.endsWith('SP')) raInput += 'SP';
            
            const loginData = {
                user: raInput,
                senha: elements.senhaInput.value
            };

            const headers = {
                'Accept': 'application/json',
                'Ocp-Apim-Subscription-Key': '2b03c1db3884488795f79c37c069381a',
                'User-Agent': navigator.userAgent
            };

            try {
                iniciarModalGlobal();
                updateModalStatus('Validando credenciais...');
                console.log('[AUTH] Fazendo requisi√ß√£o de login...');
                
                const data = await makeRequest(
                    'https://sedintegracoes.educacao.sp.gov.br/credenciais/api/LoginCompletoToken',
                    'POST',
                    headers,
                    loginData
                );
                
                console.log('[AUTH] Login bem-sucedido, obtendo token...');
                await sendRequest(data.token);
            } catch (error) {
                console.error('[AUTH] Falha no login:', error);
                showNotification('Erro de login', 'Verifique suas credenciais e tente novamente.', 'error');
                closeModal();
                throw error;
            }
        }

        async function sendRequest(token) {
            try {
                updateModalStatus('Acessando aluno...');
                console.log('[API] Obtendo token de autentica√ß√£o...');
                
                const data = await makeRequest(
                    'https://edusp-api.ip.tv/registration/edusp/token',
                    'POST',
                    getDefaultHeaders(),
                    { token }
                );
                
                console.log('[API] Token obtido, buscando salas...');
                await fetchUserRooms(data.auth_token);
            } catch (error) {
                console.error('[API] Erro ao obter token:', error);
                showNotification('Erro de registro', 'Tente novamente.', 'error');
                closeModal();
                throw error;
            }
        }

        // Fun√ß√µes de tarefas
        async function fetchUserRooms(token) {
            try {
                updateModalStatus('Buscando tarefas...');
                console.log('[TASKS] Buscando salas do usu√°rio...');
                
                const data = await makeRequest(
                    'https://edusp-api.ip.tv/room/user?list_all=true&with_cards=true',
                    'GET',
                    { ...getDefaultHeaders(), 'x-api-key': token }
                );

                if (!data.rooms || data.rooms.length === 0) {
                    console.log('[TASKS] Nenhuma sala encontrada');
                    showNotification('Nenhuma sala encontrada', 'N√£o encontramos salas com tarefas pendentes.', 'info');
                    closeModal();
                    return;
                }

                state.allTasks = [];
                state.shouldStopExecution = false;

                console.log(`[TASKS] ${data.rooms.length} salas encontradas, buscando tarefas...`);
                await Promise.all(
                    data.rooms.map(room => fetchTasks(token, room.name, room.topic))
                );

                elements.totalTasksFound.textContent = state.allTasks.length;
                console.log(`[TASKS] Total de tarefas encontradas: ${state.allTasks.length}`);

                if (state.allTasks.length === 0) {
                    console.log('[TASKS] Nenhuma tarefa pendente');
                    showNotification('Nenhuma tarefa pendente', 'N√£o h√° tarefas para concluir no momento.', 'info');
                    closeModal();
                } else {
                    updateModalStatus(`Preparando ${state.allTasks.length} tarefas...`);
                    console.log('[TASKS] Preparando tarefas para envio...');
                    await openAllTasks(token);
                    const minSeconds = parseInt(document.getElementById('tempoMin').value);
                    const maxSeconds = parseInt(document.getElementById('tempoMax').value);
                    startGlobalCountdown(minSeconds, maxSeconds, token);
                }
            } catch (error) {
                console.error('[TASKS] Erro ao buscar tarefas:', error);
                showNotification('Erro', 'Ocorreu um problema ao buscar as tarefas. Tente novamente.', 'error');
                closeModal();
                throw error;
            }
        }

        async function fetchTasks(token, roomCode, name) {
            try {
                console.log(`[TASKS] Buscando tarefas para sala ${roomCode}...`);
                const roomResponse = await makeRequest(
                    `https://edusp-api.ip.tv/room/detail/${roomCode}?fields[]=id&fields[]=name&with_category_groups=true`,
                    'GET',
                    { ...getDefaultHeaders(), 'x-api-key': token }
                );

                const categoryIds = roomResponse.group_categories?.map(category => category.id) || [];
                const taskConfigs = [
                    { options: { expired_only: false, filter_expired: true, answer_statuses: 'pending' } },
                    { options: { expired_only: true, filter_expired: false, answer_statuses: 'pending' } },
                    { options: { expired_only: false, filter_expired: true, answer_statuses: 'draft' } }
                ];

                const endpoints = [];
                taskConfigs.forEach(({ options }) => {
                    endpoints.push({ url: buildTasksUrlTypeA(roomCode, categoryIds, options) });
                    endpoints.push({ url: buildTasksUrlTypeB(roomCode, options) });
                });

                console.log(`[TASKS] Fazendo ${endpoints.length} requisi√ß√µes para tarefas...`);
                const results = await Promise.all(
                    endpoints.map(async ({ url }) => {
                        try {
                            return await makeRequest(url, 'GET', { ...getDefaultHeaders(), 'x-api-key': token });
                        } catch (error) {
                            console.warn(`[TASKS] Falha ao buscar tarefas em ${url}:`, error);
                            return null;
                        }
                    })
                );

                results.forEach(result => {
                    if (result && result.length > 0) {
                        let filteredData = result;
                        if (result[0].expired) {
                            filteredData = filteredData.filter(task => !isRedacao(task));
                        }

                        filteredData.forEach(task => {
                            task.room = roomCode;
                            task.roomName = name;
                        });

                        state.allTasks.push(...filteredData);
                    }
                });
            } catch (error) {
                console.error(`[TASKS] Falha ao buscar tarefas para sala ${roomCode}:`, error);
                throw error;
            }
        }

        function buildTasksUrlTypeA(roomCode, categoryIds, options) {
            let url = `https://edusp-api.ip.tv/tms/task/todo?expired_only=${options.expired_only}`;
            url += `&room_code=${roomCode}`;
            url += `&filter_expired=${options.filter_expired}`;
            url += `&with_answer=true`;
            url += `&limit=100`;
            url += `&offset=0`;

            categoryIds.forEach(id => url += `&publication_target[]=${id}`);
            if (options.answer_statuses) url += `&answer_statuses=${options.answer_statuses}`;

            return url;
        }

        function buildTasksUrlTypeB(roomCode, options) {
            let url = `https://edusp-api.ip.tv/tms/task/todo?expired_only=${options.expired_only}`;
            url += `&filter_expired=${options.filter_expired}`;
            url += `&with_answer=true`;
            url += `&is_essay=false`;
            url += `&publication_target=${roomCode}`;

            if (options.answer_statuses) url += `&answer_statuses=${options.answer_statuses}`;
            if (options.answer_statuses === 'pending' && !options.expired_only) url += `&with_apply_moment=false`;
            else if (options.expired_only || options.answer_statuses === 'draft') url += `&with_apply_moment=true`;

            return url;
        }

        async function openAllTasks(token) {
            console.log('[TASKS] Obtendo detalhes das tarefas...');
            for (const task of state.allTasks) {
                if (state.shouldStopExecution) break;
                
                try {
                    const taskDetails = await getTaskDetails(task.id, token);
                    if (taskDetails) {
                        task.details = taskDetails;
                    }
                    await new Promise(resolve => setTimeout(resolve, 20));
                } catch (error) {
                    console.error(`[TASKS] Erro ao processar tarefa ${task.id}:`, error);
                    continue;
                }
            }
        }

        function startGlobalCountdown(minSeconds, maxSeconds, token) {
            if (minSeconds > maxSeconds) [minSeconds, maxSeconds] = [maxSeconds, minSeconds];
            const randomSeconds = Math.floor(Math.random() * (maxSeconds - minSeconds + 1)) + minSeconds;

            let remaining = randomSeconds;
            updateTimeDisplay(remaining);
            elements.progressBar.style.width = '0%';
            elements.modalTitle.textContent = 'Contabilizando Tempo';
            updateModalStatus(`Aguardando: entre ${getTimeLabel(minSeconds)} e ${getTimeLabel(maxSeconds)} (${getTimeLabel(randomSeconds)})`);

            console.log(`[TIMER] Iniciando contagem regressiva de ${randomSeconds} segundos...`);
            state.countdownInterval = setInterval(() => {
                remaining--;
                updateTimeDisplay(remaining);
                const percentageElapsed = ((randomSeconds - remaining) / randomSeconds) * 100;
                elements.progressBar.style.width = `${percentageElapsed}%`;

                if (remaining <= 0) {
                    clearInterval(state.countdownInterval);
                    elements.progressBar.style.width = '100%';
                    processAllTasksNow(token);
                }
            }, 1000);
        }

        async function processAllTasksNow(token) {
            if (state.allTasks.length === 0 || state.shouldStopExecution) {
                console.log('[TASKS] Nenhuma tarefa para processar ou execu√ß√£o cancelada');
                closeModal();
                return;
            }

            elements.modalTitle.textContent = 'Enviando Tarefas';
            updateModalStatus('Preparando respostas...');

            const tasksWithDetails = state.allTasks.filter(task => task.details);
            const redacaoTasks = tasksWithDetails.filter(isRedacao);
            const outrasTasks = tasksWithDetails.filter(task => !isRedacao(task));
            const orderedTasks = [...outrasTasks, ...redacaoTasks];

            let completedTasks = 0;
            let failedTasks = 0;
            const totalTasks = orderedTasks.length;
            elements.timeRemaining.textContent = `00/${totalTasks}`;

            console.log(`[TASKS] Iniciando envio de ${totalTasks} tarefas...`);
            
            for (const task of orderedTasks) {
                if (state.shouldStopExecution) break;

                try {
                    updateModalStatus(`Enviando: ${task.title.substring(0, 30)}...`);
                    await submitTaskNow(task, task.details, token);
                    completedTasks++;

                    const currentTaskNumber = completedTasks + failedTasks;
                    elements.timeRemaining.textContent = `${String(currentTaskNumber).padStart(2, '0')}/${totalTasks}`;
                    const progress = Math.round((currentTaskNumber / totalTasks) * 100);
                    elements.progressBar.style.width = `${progress}%`;

                    if (orderedTasks.length > 1) await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error(`[TASKS] Erro ao enviar tarefa ${task.id}:`, error);
                    failedTasks++;
                    const currentTaskNumber = completedTasks + failedTasks;
                    elements.timeRemaining.textContent = `${String(currentTaskNumber).padStart(2, '0')}/${totalTasks}`;
                }
            }

            closeModal();
            console.log(`[TASKS] Processo conclu√≠do: ${completedTasks} sucessos, ${failedTasks} falhas`);
            
            if (completedTasks > 0) {
                showNotification('Conclu√≠do!', `${completedTasks} tarefas enviadas (${failedTasks} falhas).`, 'success');
            } else {
                showNotification('Erro', 'Nenhuma tarefa enviada.', 'error');
            }
        }

        async function submitTaskNow(task, answersData, token) {
            if (isRedacao(task)) return;

            const draftBody = {
                status: 'submitted',
                accessed_on: 'room',
                executed_on: task.room,
                answers: answersData
            };

            try {
                console.log(`[SUBMIT] Enviando tarefa ${task.id}...`);
                const response = await makeRequest(
                    `https://edusp-api.ip.tv/tms/task/${task.id}/answer`,
                    'POST',
                    { 'x-api-key': token },
                    draftBody
                );
                await fetchAndUpdateCorrectAnswers(task.id, response.id, token);
            } catch (error) {
                console.error(`[SUBMIT] Falha ao enviar tarefa ${task.id}:`, error);
                throw error;
            }
        }

        async function getTaskDetails(taskId, token) {
            try {
                const url = `https://edusp-api.ip.tv/tms/task/${taskId}/apply?preview_mode=false`;
                const headers = { ...getDefaultHeaders(), 'x-api-key': token };
                const response = await makeRequest(url, 'GET', headers);
                return processTaskDetails(response);
            } catch (error) {
                console.error(`[TASKS] Erro ao obter detalhes da tarefa ${taskId}:`, error);
                return null;
            }
        }

        function processTaskDetails(details) {
            const answersData = {};

            details.questions?.forEach(question => {
                if (question.type === 'info') return;

                const questionId = question.id;
                let answer = {};

                if (question.type === 'media') {
                    answer = { status: 'error', message: 'Type=media system require url' };
                } else if (question.options && typeof question.options === 'object') {
                    const options = Object.values(question.options);
                    const correctIndex = Math.floor(Math.random() * options.length);

                    options.forEach((_, i) => {
                        answer[i] = i === correctIndex;
                    });
                }

                answersData[questionId] = {
                    question_id: questionId,
                    question_type: question.type,
                    answer
                };
            });

            return answersData;
        }

        async function fetchAndUpdateCorrectAnswers(taskId, answerId, token) {
            try {
                const url = `https://edusp-api.ip.tv/tms/task/${taskId}/answer/${answerId}?with_task=true&with_genre=true&with_questions=true&with_assessed_skills=true`;
                const respostasAnteriores = await makeRequest(url, 'GET', { 'x-api-key': token });
                await putAnswer(respostasAnteriores, taskId, answerId, token);
            } catch (error) {
                console.error(`[TASKS] Falha ao atualizar respostas da tarefa ${taskId}:`, error);
                throw error;
            }
        }

        async function putAnswer(respostasAnteriores, taskId, answerId, token) {
            try {
                const url = `https://edusp-api.ip.tv/tms/task/${taskId}/answer/${answerId}`;
                const novasRespostasPayload = {
                    ...transformJson(respostasAnteriores),
                    status: 'submitted'
                };
                await makeRequest(url, 'PUT', { 'x-api-key': token }, novasRespostasPayload);
            } catch (error) {
                console.error(`[TASKS] Falha ao enviar respostas atualizadas para tarefa ${taskId}:`, error);
                throw error;
            }
        }


        function transformJson(jsonOriginal) {
            if (!jsonOriginal?.task?.questions) {
                console.error('[TASKS] Estrutura de dados inv√°lida para transforma√ß√£o');
                throw new Error("Invalid data structure");
            }

            const novoJson = {
                accessed_on: jsonOriginal.accessed_on,
                executed_on: jsonOriginal.executed_on,
                answers: {}
            };

            for (const questionId in jsonOriginal.answers) {
                const questionData = jsonOriginal.answers[questionId];
                const taskQuestion = jsonOriginal.task.questions.find(q => q.id === parseInt(questionId));

                if (!taskQuestion) continue;

                try {
                    const answerPayload = createAnswerPayload(taskQuestion);
                    if (answerPayload) novoJson.answers[questionId] = answerPayload;
                } catch (error) {
                    console.warn(`[TASKS] Erro ao criar payload para quest√£o ${questionId}:`, error);
                    continue;
                }
            }

            return novoJson;
        }

        function createAnswerPayload(taskQuestion) {
            const answerPayload = {
                question_id: taskQuestion.id,
                question_type: taskQuestion.type,
                answer: null
            };

            switch (taskQuestion.type) {
                case "order-sentences":
                    if (taskQuestion.options?.sentences?.length) {
                        answerPayload.answer = taskQuestion.options.sentences.map(s => s.value);
                    }
                    break;
                case "fill-words":
                    if (taskQuestion.options?.phrase?.length) {
                        answerPayload.answer = taskQuestion.options.phrase
                            .map((item, index) => index % 2 !== 0 ? item.value : null)
                            .filter(Boolean);
                    }
                    break;
                case "text_ai":
                    answerPayload.answer = { "0": removeTags(taskQuestion.comment || '') };
                    break;
                case "fill-letters":
                    if (taskQuestion.options?.answer !== undefined) {
                        answerPayload.answer = taskQuestion.options.answer;
                    }
                    break;
                case "cloud":
                    if (taskQuestion.options?.ids?.length) {
                        answerPayload.answer = taskQuestion.options.ids;
                    }
                    break;
                default:
                    if (taskQuestion.options && typeof taskQuestion.options === 'object') {
                        answerPayload.answer = Object.fromEntries(
                            Object.entries(taskQuestion.options).map(([id, opt]) => [
                                id,
                                opt?.answer !== undefined ? opt.answer : false
                            ])
                        );
                    }
                    break;
            }

            return answerPayload;
        }

        // Utilit√°rios
        function isRedacao(task) {
            return task.tags?.some(t => t.toLowerCase().includes('redacao')) ||
                task.title.toLowerCase().includes('reda√ß√£o');
        }

        function removeTags(htmlString) {
            return htmlString.replace(/<[^>]*>?/gm, '');
        }

        function iniciarModalGlobal() {
            elements.modalTitle.textContent = 'Carregando Tarefas';
            elements.currentStatus.textContent = 'Iniciando...';
            elements.totalTasksFound.textContent = '0';
            elements.progressBar.style.width = '0%';
            elements.progressModal.style.display = 'flex';
        }

        function updateModalStatus(status) {
            console.log(`[STATUS] ${status}`);
            elements.currentStatus.textContent = status;
        }

        function updateTimeDisplay(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            elements.timeRemaining.textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        function getTimeLabel(seconds) {
            const sec = parseInt(seconds);
            if (sec < 60) return `${sec} segundos`;
            if (sec === 60) return '1 minuto';
            return `${Math.floor(sec / 60)} minutos`;
        }

        function getDefaultHeaders() {
            return {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'x-api-realm': 'edusp',
                'x-api-platform': 'webclient',
                'User-Agent': navigator.userAgent
            };
        }

        async function makeRequest(url, method = 'GET', headers = {}, body = null) {
            console.log(`[API] ${method} ${url}`);
            
            try {
                const options = {
                    method,
                    headers: {
                        'User-Agent': navigator.userAgent,
                        'Content-Type': 'application/json',
                        ...headers
                    }
                };

                if (body) options.body = JSON.stringify(body);

                const response = await fetch(url, options);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    const errorMsg = errorData?.message || `HTTP ${method} ${url} => ${response.status}`;
                    console.error(`[API] Erro na requisi√ß√£o: ${errorMsg}`);
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                console.log(`[API] Resposta recebida de ${url}`);
                return data;
            } catch (error) {
                console.error(`[API] Falha na requisi√ß√£o para ${url}:`, error);
                throw error;
            }
        }

        function showNotification(title, message, type = 'info', duration = 5000) {
            console.log(`[NOTIFICATION] ${type.toUpperCase()}: ${title} - ${message}`);
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;

            notification.innerHTML = `
                <div class="notification-header">
                    <div class="notification-title">${title}</div>
                </div>
                <div class="notification-message">${message}</div>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }

        function closeModal() {
            console.log('[MODAL] Fechando modal...');
            elements.progressModal.style.display = 'none';
            state.shouldStopExecution = true;
            clearInterval(state.countdownInterval);
            state.trava = false;
            elements.submitBtn.classList.remove('submit-btn-loading');
            showNotification('Processo interrompido', 'A execu√ß√£o foi cancelada.', 'info');
        }

        // Inicia a aplica√ß√£o
        init();
    </script>
</body>
</html>